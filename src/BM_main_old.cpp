/*
Main BlooMine module. Parses arguments and controls FastQ data pre-processing and thread spawning.
*/

#include "BlooMine.hpp"
#include "constants.hpp"


/****************************************************************************************************
 * Function overview:
 *  - parse arguments (vm)
 *  - initialise a FastQ instance (FQ)
 *  - call partition method to partition reads dependant on the number of threads selected
 *    (FQ.partition)
 *  - spawn threads using individual partitions generated by FastQ.partition (spawn_thread)
 *  - control output of read hits into a fastq file (hits_collection)
 ****************************************************************************************************/
int main( int argc, char** argv )
{
  // parse arguments
  po::variables_map vm = parseArgs( argc, argv );

  // run first pass screen
  vprint("FP-ALN", "Started BlooMine with parameters:", "g");
  printParams( vm );

  // generate a Bloom Filter from the target fastq and arguments
  int fp_threshold;
  BloomFilter BF = genBF( vm, fp_threshold );

  // generate a kmer set from the target sequence
  std::unordered_set<std::string> target_kset = fasta2kmerset( vm["target_fasta"].as<std::string>(), vm["kmer"].as<int>() );

  // calculate the min score threshold for the target sequence for use during second-pas screening
  const double spMST =  minscore( target_kset.size(), vm["SP-error"].as<float>(), vm["kmer"].as<int>(), hit, gap_open, neg );
  vprint("SP-SCREEN", "MINIMUM SCORE THRESHOLD SET TO : " + std::to_string(spMST), "g");

  // Read the entire FASTQ file into memory
  std::vector<std::string> read_data = readFQ( vm["fastq"].as<std::string>() );

  // Partition the read data into chunks
  const int num_threads = vm["threads"].as<int>();
  const size_t chunk_size = (read_data.size()/4) / num_threads;

  // Create a vector of futures to store the results from each thread
  std::vector<std::future<std::vector<std::string>>> hits_collection;

  // initialise and open read hit outfile
  std::ofstream fp_outfile;
  fp_outfile.open( vm["prefix"].as<std::string>() + "_BMfiltered.fq", std::ios::out );

  vprint( "FP-SCREEN", "Starting BlooMine screening pipeline...", "g" );
  // Spawn threads
  for (int tnum = 0; tnum < num_threads; ++tnum) {
    size_t chunk_lines = chunk_size*4;
    size_t start = tnum * chunk_lines;
    size_t end = (tnum == num_threads - 1) ? read_data.size() : (tnum + 1) * chunk_lines;
    std::vector<std::string> chunk(read_data.begin() + start, read_data.begin() + end);

    // cout << "\t\tThread created : " << tnum << "\tfqpart : " << chunk.size() << endl;
    std::future<std::vector<std::string>> fp = std::async( runBM, vm, chunk, BF, target_kset, fp_threshold, spMST, hit, gap_open, neg );
    hits_collection.push_back(std::move(fp));
  }

  // Collect results from threads
  for (auto& fp : hits_collection) {
    std::vector<std::string> hitsvec = fp.get();
    for (auto& read : hitsvec) {
      fp_outfile << read;
    }
  }
  fp_outfile.close();

  vprint("FP-ALN", "Finished screening.", "g");

  // check and run MOI screening
  // if ( vm["MOI"] ) {
  //   vprint("MOI", "Starting MOI screening", "g");
  // }
  return 0;
}


/****************************************************************************************************
 * PARALLEL FUNCTION - RUN BLOOMINE PIPELINE.
 * Reads through and screens each read within the fq_part fastq file.
 *
 * INPUT:
 *  vm <po:variables_map> : boost program options map containing arguments and options provided
 *                          to this program
 *  fq_part <string>      : path to a read file (or a partition of one) in fastq format
 *  BF <BloomFilter>      : a Bloom filter generated using the target sequence
 *  fp_threshold <int>    : a threshold for number of kmer hits to call a read hit during
 *                          first-pass screening
 *
 * OUTPUT:
 *  read_hits <vector<string>> : a vector of reads which contain the target sequence
 ****************************************************************************************************/
std::vector<std::string> runBM( po::variables_map vm,
                                std::vector<std::string> read_data_part,
                                BloomFilter BF,
                                std::unordered_set<std::string> target_kset,
                                const int fp_threshold,
                                const double spMST,
                                const double hit,
                                const double gap_open,
                                const double neg ) {

  // Iterate through the FASTQ file line by line
  std::vector<std::string> read_hits;
  std::vector<std::string> read_box;
  std::string line;
  std::int32_t lc = 0;

  for (size_t i = 0; i < read_data_part.size(); i++) {
    lc++; // Increment line counter

    line = read_data_part[i];

    if ( lc % 4 != 0 ) {  // check if the linecounter has reached a new block
      read_box.push_back(line);
    } else {
      read_box.push_back(line);    // capture the description line
      
      // Check if the read is complete
      if (read_box.size() == 4) {

        // Screen block
        FQread Read( read_box[1], vm["kmer"].as<int>(), hit, gap_open, neg );

        // Screen reads
        if ( Read.FPscreen( BF, fp_threshold ) ) {            // if read passes first-pass screen
          if ( Read.SPscreen( target_kset, spMST ) ) {        // if read passes second-pass screen

            std::string read_concat;
            for ( const auto & l : read_box ) { read_concat += l + "\n"; }
            read_hits.push_back(read_concat);
            // std::cout << read_concat;
          }
        } else {
          // reverse complement the read sequence and rerun through the BF, adding to the counter on hits
          // Screen block for complementing the read
          std::string readseqRC = reverseCompliment( read_box[1] );
          FQread Read( readseqRC, vm["kmer"].as<int>(), hit, gap_open, neg );

          if ( Read.FPscreen( BF, fp_threshold ) ) {            // if reverse complemented read passes first-pass screen
            if ( Read.SPscreen( target_kset, spMST ) ) {        // if reverse complemented read passes second-pass screen
            
              std::string read_concat;
              for ( const auto & l : read_box ) { read_concat += l + "\n"; }
              read_hits.push_back(read_concat);
            }
          }
        }

        read_box.clear(); // redefine the vector as empty
      }
    }
  }

  return read_hits;
}


/****************************************************************************************************
 * Generate a Bloom Filter from the target sequence.
 *
 * INPUT:
 *  vm <variables_map> : a boost program options map containing argument variables
 *  threshold <int&>   : mem addr of the threshold variable
 *
 * OUTPUT:
 *  BF <BloomFilter> : a Bloom Filter generated from the target sequence, using a given FP rate
 *
 * MODIFIES:
 *  threshold <int> main : the threshold for kmer hits to call a read hit
 ****************************************************************************************************/
BloomFilter genBF( po::variables_map vm, int& threshold ) {

  std::unordered_set<std::string> kmer_array;

  try {
    kmer_array = fasta2kmerset( vm["target_fasta"].as<std::string>(), vm["kmer"].as<int>() );
  }
  catch ( const std::out_of_range& oor ) {
    vprint( "FA-ERROR", "Generation of kmer array from " + vm["target_fasta"].as<std::string>() + " failed. Exiting...", "r" );
    exit(1);
  }

  threshold = kmer_array.size() * vm["FP-sim"].as<float>()/100;     // define the minimum number of kmers that must match to return a read hit
  // cout << "threshold : " << threshold << endl;         // uncomment for debugging

  BloomFilter BF(kmer_array.size(), vm["false_positive"].as<float>());

  for ( auto & kmer : kmer_array ) { BF.push(kmer); } // iterates through the target kmer array and pushes each kmer into the Bloom Filters

  return BF;
}


/****************************************************************************************************
 * Checks and reads a FASTQ file.
 *
 * INPUT:
 *  fq_file <string> : the path to a FASTQ file
 *
 * OUTPUT:
 *  read_data <vector> : a vector containing all reads within the FASTQ file
 ****************************************************************************************************/
std::vector<std::string> readFQ( std::string fastq_in ) {

  std::vector<std::string> read_data;
  std::stringstream ss(fastq_in);
  std::string fq_file;

  while (std::getline(ss, fq_file, ',')) {
    std::ifstream inFQ(fq_file, std::ios::binary);

    if (!inFQ.good()) {
      std::cerr << "FQ-ERROR: Cannot open FASTQ file: " << fq_file << std::endl;
      exit(1);
    }

    std::string line;
    while (std::getline(inFQ, line)) {
      read_data.push_back(line);
    }
    inFQ.close();
  }

  return read_data;
}


/****************************************************************************************************
 * Parses arguments for the BlooMine pipeline.
 *
 * INPUT:
 *  argc <int> : the number of arguments provided
 *  argv <char**> : a ptr-ptr to the arguments
 *
 * OUTPUT:
 *  vm <variables_map> : a boost program options map containing argument variables
 ****************************************************************************************************/
po::variables_map parseArgs( int argc, char** argv ) {

  int threads;
  int k = 0;
  float f = 0.0;
  float s = 0.0;
  float e = 0.0;
  checkArgc( argc, argv );     // check the number of args provided

  // Declare the supported options.
  po::options_description desc("Allowed options");

  // boost::po args parse
  try {
    desc.add_options()
      ("help,h",          "Show this message and exit.")
      ("target_fasta,t",  po::value<std::string>()->required(),                       "file containing target sequences. Supported formats: FASTA")
      ("fastq,q",         po::value<std::string>()->required(),                       "file containing reads to be screened for containing taret sequences. Supported formats: FASTQ")
      ("prefix",          po::value<std::string>()->default_value("BM")->required(),  "prefix for output files. Default=BM")
      ("kmer",            po::value<int>(&k)->default_value(7)->required(),           "set kmer size. Default = 7")
      ("false_positive",  po::value<float>(&f)->default_value(0.0001)->required(),    "false positive rate for building the Bloom filter. Range = 0-1. Default = 0.0001")
      ("FP-sim",          po::value<float>(&s)->default_value(50.0)->required(),      "FP-screen threshold for gene orthology inference as a percentage of kmer array identity. Range = 0-100. Default = 50.0")
      ("SP-error",        po::value<float>(&e)->default_value(4.0)->required(),       "SP-screen screening error threshold for alignment, where the maximum number of errors to return a read as a hit is 1/n given n. Default = 4.0.")
      ("threads",         po::value<int>(&threads)->default_value(4)->required(),     "number of threads to use. Must be an even <int>. Default = 4");

    po::variables_map vm;
    po::store(po::parse_command_line(argc, argv, desc), vm);

    if ( vm.count("help") ) {
      cout << desc << "\n";
      exit(0);
    }

    po::notify(vm);

    // argscheck chunk
    if ( threads != 1 ) { checkThreadCount( threads ); }  // just returns if running in single core mode
    checkFloats( f, s );  // check the args of the false positive and FP-sim floats
    checkKsize( k );     // check the given kmer size

    return vm;
  }

  catch ( const po::error& e ) {
    cerr << "ARG-ERROR: " << e.what() << endl << endl;
    cerr << desc << endl;
    exit (1);
  }
}


/****************************************************************************************************
 * Check the number of arguments provided to BlooMine.
 * Throws an exception (kind of) if too few are provided.
 *
 * INPUT:
 *  argc <int> : the number of arguments provided
 *  argv <char**> : a ptr-ptr to the arguments
 ****************************************************************************************************/
void checkArgc( int argc, char** argv) {

  try {
    if (argc < 2) {
      throw argc;
    }
  }
  catch ( int argc ) {
    cerr << "Too few argument provided! Please use -h or --help to see arguments." << endl;
    exit(1);
  }
}


/****************************************************************************************************
 * Checks the given threadcount is suitable.
 * i.e. threads <= number of available threads, threads = 1, or threads%2 != 0
 * Throws an exception (kind of) if one or more of the above are false.
 *
 * INPUT:
 *  threads <int> : the number of threads requested in arguments
 ****************************************************************************************************/
void checkThreadCount( int threads ) {

  const auto processor_count = std::thread::hardware_concurrency();
  try {
    if ( threads%2 != 0 || threads>processor_count ) {
      throw threads;
    }
  }
  catch ( int threads ) {
    std::string error_msg = "Inappropriate thread count specified. Must be an even <int> of between 1 and " + std::to_string(processor_count) + ". Exiting...";
    vprint( "ARG-ERROR", error_msg, "r" );
    exit(1);
  }
}


/****************************************************************************************************
 * Checks that the false postitive rate and FP-sim scores are within acceptable range.
 *
 * INPUT:
 *  f <float> : the false positive rate
 *  s <float> : the minimum acceptable similarity score for first pass screening
 ****************************************************************************************************/
void checkFloats( float f, float s ) {
  /* Checks that the false postitive rate and FP-sim scores are within acceptable range
  */

  try {
    if ( f < 0 || f > 1.0 ) {
      throw f;
    }
  }
  catch ( float f ) {
    vprint("ARG-ERROR", "False-positive rate must be between 0-1. Exiting...", "r");
    exit(1);
  }

  try {
    if ( s < 0 || s > 100 ) {
      throw s;
    }
  }
  catch ( float s ) {
    vprint("ARG-ERROR", "Kmer array FP-sim must be between 0-100. Exiting...", "r");
    exit(1);
  }
}


/****************************************************************************************************
 * Checks given kmer size isnt silly.
 *
 * INPUT:
 *  k <int> : the given kmer size
 ****************************************************************************************************/
void checkKsize( int k ) {
  /* Checks given kmer size isnt silly
  */

  try {
    if ( k < 3 ) {
      throw k;
    } else if ( k >= 3 && k <= 5 ) {
      vprint("ARG-WARNING", "Kmer size is small. This may give unexpected results. Proceeding with due pessimism...", "y");
    }
  }
  catch ( int k ) {
    vprint("ARG-ERROR", "Kmer size too small. Please specific a larger value. Exiting...", "r");
    exit(1);
  }
}


/****************************************************************************************************
 * Prints parameters to stdout during runtime.
 *
 * INPUT:
 *  vm <variables_map> : a boost program options map containing argument variables
 ****************************************************************************************************/
void printParams( po::variables_map vm ) {

  cout << "\t\ttarget_fasta : " << vm["target_fasta"].as<std::string>() << "\n"
  << "\t\tfastq : " << vm["fastq"].as<std::string>() << "\n"
  << "\t\tkmer : " << vm["kmer"].as<int>() << "\n"
  << "\t\tFP : " << vm["false_positive"].as<float>() << "\n"
  << "\t\tFP-sim : " << vm["FP-sim"].as<float>() << "\n"
  << "\t\tSP-error : " << vm["SP-error"].as<float>() << "\n"
  << "\t\tthreads : " << vm["threads"].as<int>() << "\n\n";
}
/*
Main BlooMine module. Parses arguments and controls FastQ data pre-processing and thread spawning.
*/

#include "BlooMine.hpp"
#include "constants.hpp"


/****************************************************************************************************
 * Function overview:
 *  - parse arguments (vm)
 *  - initialise a FastQ instance (FQ)
 *  - call partition method to partition reads dependant on the number of threads selected
 *    (FQ.partition)
 *  - spawn threads using individual partitions generated by FastQ.partition (spawn_thread)
 *  - control output of read hits into a fastq file (hits_collection)
 ****************************************************************************************************/
int main( int argc, char** argv )
{
  // parse arguments
  po::variables_map vm = parseArgs( argc, argv );

  // run first pass screen
  vprint("FP-ALN", "Started BlooMine with parameters:", "g");
  printParams( vm );

  // generate a Bloom Filter from the target fastq and arguments
  int fp_threshold;
  BloomFilter BF = genBF( vm, fp_threshold );

  // generate a kmer set from the target sequence
  std::unordered_set<std::string> target_kset = fasta2kmerset( vm["target_fasta"].as<std::string>(), vm["kmer"].as<int>() );

  // calculate the min score threshold for the target sequence for use during second-pas screening
  const double spMST =  minscore( target_kset.size(), vm["SP-error"].as<float>(), vm["kmer"].as<int>(), hit, gap_open, neg );
  vprint("SP-SCREEN", "MINIMUM SCORE THRESHOLD SET TO : " + std::to_string(spMST), "g");

  // Read the entire FASTQ file into memory
  std::vector<std::string> read_data = readFQ( vm["fastq"].as<std::string>() );

  // Partition the read data into chunks
  const int num_threads = vm["threads"].as<int>();
  const size_t chunk_size = (read_data.size()/4) / num_threads;

  // Create a vector of futures to store the results from each thread
  std::vector<std::future<std::vector<std::string>>> hits_collection;

  // initialise and open read hit outfile
  std::ofstream fp_outfile;
  fp_outfile.open( vm["prefix"].as<std::string>() + "_BMfiltered.fq", std::ios::out );

  vprint( "FP-SCREEN", "Starting BlooMine screening pipeline...", "g" );
  // Spawn threads
  for (int tnum = 0; tnum < num_threads; ++tnum) {
    size_t chunk_lines = chunk_size*4;
    size_t start = tnum * chunk_lines;
    size_t end = (tnum == num_threads - 1) ? read_data.size() : (tnum + 1) * chunk_lines;
    std::vector<std::string> chunk(read_data.begin() + start, read_data.begin() + end);

    // cout << "\t\tThread created : " << tnum << "\tfqpart : " << chunk.size() << endl;
    std::future<std::vector<std::string>> fp = std::async( runBM, vm, chunk, BF, target_kset, fp_threshold, spMST, hit, gap_open, neg );
    hits_collection.push_back(std::move(fp));
  }

  // Collect results from threads
  for (auto& fp : hits_collection) {
    std::vector<std::string> hitsvec = fp.get();
    for (auto& read : hitsvec) {
      fp_outfile << read;
    }
  }
  fp_outfile.close();

  vprint("FP-ALN", "Finished screening.", "g");

  // check and run MOI screening
  // if ( vm["MOI"] ) {
  //   vprint("MOI", "Starting MOI screening", "g");
  // }
  return 0;
}


/****************************************************************************************************
 * PARALLEL FUNCTION - RUN BLOOMINE PIPELINE.
 * Reads through and screens each read within the fq_part fastq file.
 *
 * INPUT:
 *  vm <po:variables_map> : boost program options map containing arguments and options provided
 *                          to this program
 *  fq_part <string>      : path to a read file (or a partition of one) in fastq format
 *  BF <BloomFilter>      : a Bloom filter generated using the target sequence
 *  fp_threshold <int>    : a threshold for number of kmer hits to call a read hit during
 *                          first-pass screening
 *
 * OUTPUT:
 *  read_hits <vector<string>> : a vector of reads which contain the target sequence
 ****************************************************************************************************/
std::vector<std::string> runBM( po::variables_map vm,
                                std::vector<std::string> read_data_part,
                                BloomFilter BF,
                                std::unordered_set<std::string> target_kset,
                                const int fp_threshold,
                                const double spMST,
                                const double hit,
                                const double gap_open,
                                const double neg ) {

  // Iterate through the FASTQ file line by line
  std::vector<std::string> read_hits;
  std::vector<std::string> read_box;
  std::string line;
  std::int32_t lc = 0;

  for (size_t i = 0; i < read_data_part.size(); i++) {
    lc++; // Increment line counter

    line = read_data_part[i];

    if ( lc % 4 != 0 ) {  // check if the linecounter has reached a new block
      read_box.push_back(line);
    } else {
      read_box.push_back(line);    // capture the description line
      
      // Check if the read is complete
      if (read_box.size() == 4) {

        // Screen block
        FQread Read( read_box[1], vm["kmer"].as<int>(), hit, gap_open, neg );

        // Screen reads
        if ( Read.FPscreen( BF, fp_threshold ) ) {            // if read passes first-pass screen
          if ( Read.SPscreen( target_kset, spMST ) ) {        // if read passes second-pass screen

            std::string read_concat;
            for ( const auto & l : read_box ) { read_concat += l + "\n"; }
            read_hits.push_back(read_concat);
            // std::cout << read_concat;
          }
        } else {
          // reverse complement the read sequence and rerun through the BF, adding to the counter on hits
          // Screen block for complementing the read
          std::string readseqRC = reverseCompliment( read_box[1] );
          FQread Read( readseqRC, vm["kmer"].as<int>(), hit, gap_open, neg );

          if ( Read.FPscreen( BF, fp_threshold ) ) {            // if reverse complemented read passes first-pass screen
            if ( Read.SPscreen( target_kset, spMST ) ) {        // if reverse complemented read passes second-pass screen
            
              std::string read_concat;
              for ( const auto & l : read_box ) { read_concat += l + "\n"; }
              read_hits.push_back(read_concat);
            }
          }
        }

        read_box.clear(); // redefine the vector as empty
      }
    }
  }

  return read_hits;
}


/****************************************************************************************************
 * Generate a Bloom Filter from the target sequence.
 *
 * INPUT:
 *  vm <variables_map> : a boost program options map containing argument variables
 *  threshold <int&>   : mem addr of the threshold variable
 *
 * OUTPUT:
 *  BF <BloomFilter> : a Bloom Filter generated from the target sequence, using a given FP rate
 *
 * MODIFIES:
 *  threshold <int> main : the threshold for kmer hits to call a read hit
 ****************************************************************************************************/
BloomFilter genBF( po::variables_map vm, int& threshold ) {

  std::unordered_set<std::string> kmer_array;

  try {
    kmer_array = fasta2kmerset( vm["target_fasta"].as<std::string>(), vm["kmer"].as<int>() );
  }
  catch ( const std::out_of_range& oor ) {
    vprint( "FA-ERROR", "Generation of kmer array from " + vm["target_fasta"].as<std::string>() + " failed. Exiting...", "r" );
    exit(1);
  }

  threshold = kmer_array.size() * vm["FP-sim"].as<float>()/100;     // define the minimum number of kmers that must match to return a read hit
  // cout << "threshold : " << threshold << endl;         // uncomment for debugging

  BloomFilter BF(kmer_array.size(), vm["false_positive"].as<float>());

  for ( auto & kmer : kmer_array ) { BF.push(kmer); } // iterates through the target kmer array and pushes each kmer into the Bloom Filters

  return BF;
}


/****************************************************************************************************
 * Checks and reads a FASTQ file.
 *
 * INPUT:
 *  fq_file <string> : the path to a FASTQ file
 *
 * OUTPUT:
 *  read_data <vector> : a vector containing all reads within the FASTQ file
 ****************************************************************************************************/
std::vector<std::string> readFQ( std::string fastq_in ) {

  std::vector<std::string> read_data;
  std::stringstream ss(fastq_in);
  std::string fq_file;

  while (std::getline(ss, fq_file, ',')) {
    std::ifstream inFQ(fq_file, std::ios::binary);

    if (!inFQ.good()) {
      std::cerr << "FQ-ERROR: Cannot open FASTQ file: " << fq_file << std::endl;
      exit(1);
    }

    std::string line;
    while (std::getline(inFQ, line)) {
      read_data.push_back(line);
    }
    inFQ.close();
  }

  return read_data;
}


/****************************************************************************************************
 * Parses arguments for the BlooMine pipeline.
 *
 * INPUT:
 *  argc <int> : the number of arguments provided
 *  argv <char**> : a ptr-ptr to the arguments
 *
 * OUTPUT:
 *  vm <variables_map> : a boost program options map containing argument variables
 ****************************************************************************************************/
po::variables_map parseArgs( int argc, char** argv ) {

  int threads;
  int k = 0;
  float f = 0.0;
  float s = 0.0;
  float e = 0.0;
  checkArgc( argc, argv );     // check the number of args provided

  // Declare the supported options.
  po::options_description desc("Allowed options");

  // boost::po args parse
  try {
    desc.add_options()
      ("help,h",          "Show this message and exit.")
      ("target_fasta,t",  po::value<std::string>()->required(),                       "file containing target sequences. Supported formats: FASTA")
      ("fastq,q",         po::value<std::string>()->required(),                       "file containing reads to be screened for containing taret sequences. Supported formats: FASTQ")
      ("prefix",          po::value<std::string>()->default_value("BM")->required(),  "prefix for output files. Default=BM")
      ("kmer",            po::value<int>(&k)->default_value(7)->required(),           "set kmer size. Default = 7")
      ("false_positive",  po::value<float>(&f)->default_value(0.0001)->required(),    "false positive rate for building the Bloom filter. Range = 0-1. Default = 0.0001")
      ("FP-sim",          po::value<float>(&s)->default_value(50.0)->required(),      "FP-screen threshold for gene orthology inference as a percentage of kmer array identity. Range = 0-100. Default = 50.0")
      ("SP-error",        po::value<float>(&e)->default_value(4.0)->required(),       "SP-screen screening error threshold for alignment, where the maximum number of errors to return a read as a hit is 1/n given n. Default = 4.0.")
      ("threads",         po::value<int>(&threads)->default_value(4)->required(),     "number of threads to use. Must be an even <int>. Default = 4");

    po::variables_map vm;
    po::store(po::parse_command_line(argc, argv, desc), vm);

    if ( vm.count("help") ) {
      cout << desc << "\n";
      exit(0);
    }

    po::notify(vm);

    // argscheck chunk
    if ( threads != 1 ) { checkThreadCount( threads ); }  // just returns if running in single core mode
    checkFloats( f, s );  // check the args of the false positive and FP-sim floats
    checkKsize( k );     // check the given kmer size

    return vm;
  }

  catch ( const po::error& e ) {
    cerr << "ARG-ERROR: " << e.what() << endl << endl;
    cerr << desc << endl;
    exit (1);
  }
}


/****************************************************************************************************
 * Check the number of arguments provided to BlooMine.
 * Throws an exception (kind of) if too few are provided.
 *
 * INPUT:
 *  argc <int> : the number of arguments provided
 *  argv <char**> : a ptr-ptr to the arguments
 ****************************************************************************************************/
void checkArgc( int argc, char** argv) {

  try {
    if (argc < 2) {
      throw argc;
    }
  }
  catch ( int argc ) {
    cerr << "Too few argument provided! Please use -h or --help to see arguments." << endl;
    exit(1);
  }
}


/****************************************************************************************************
 * Checks the given threadcount is suitable.
 * i.e. threads <= number of available threads, threads = 1, or threads%2 != 0
 * Throws an exception (kind of) if one or more of the above are false.
 *
 * INPUT:
 *  threads <int> : the number of threads requested in arguments
 ****************************************************************************************************/
void checkThreadCount( int threads ) {

  const auto processor_count = std::thread::hardware_concurrency();
  try {
    if ( threads%2 != 0 || threads>processor_count ) {
      throw threads;
    }
  }
  catch ( int threads ) {
    std::string error_msg = "Inappropriate thread count specified. Must be an even <int> of between 1 and " + std::to_string(processor_count) + ". Exiting...";
    vprint( "ARG-ERROR", error_msg, "r" );
    exit(1);
  }
}


/****************************************************************************************************
 * Checks that the false postitive rate and FP-sim scores are within acceptable range.
 *
 * INPUT:
 *  f <float> : the false positive rate
 *  s <float> : the minimum acceptable similarity score for first pass screening
 ****************************************************************************************************/
void checkFloats( float f, float s ) {
  /* Checks that the false postitive rate and FP-sim scores are within acceptable range
  */

  try {
    if ( f < 0 || f > 1.0 ) {
      throw f;
    }
  }
  catch ( float f ) {
    vprint("ARG-ERROR", "False-positive rate must be between 0-1. Exiting...", "r");
    exit(1);
  }

  try {
    if ( s < 0 || s > 100 ) {
      throw s;
    }
  }
  catch ( float s ) {
    vprint("ARG-ERROR", "Kmer array FP-sim must be between 0-100. Exiting...", "r");
    exit(1);
  }
}


/****************************************************************************************************
 * Checks given kmer size isnt silly.
 *
 * INPUT:
 *  k <int> : the given kmer size
 ****************************************************************************************************/
void checkKsize( int k ) {
  /* Checks given kmer size isnt silly
  */

  try {
    if ( k < 3 ) {
      throw k;
    } else if ( k >= 3 && k <= 5 ) {
      vprint("ARG-WARNING", "Kmer size is small. This may give unexpected results. Proceeding with due pessimism...", "y");
    }
  }
  catch ( int k ) {
    vprint("ARG-ERROR", "Kmer size too small. Please specific a larger value. Exiting...", "r");
    exit(1);
  }
}


/****************************************************************************************************
 * Prints parameters to stdout during runtime.
 *
 * INPUT:
 *  vm <variables_map> : a boost program options map containing argument variables
 ****************************************************************************************************/
void printParams( po::variables_map vm ) {

  cout << "\t\ttarget_fasta : " << vm["target_fasta"].as<std::string>() << "\n"
  << "\t\tfastq : " << vm["fastq"].as<std::string>() << "\n"
  << "\t\tkmer : " << vm["kmer"].as<int>() << "\n"
  << "\t\tFP : " << vm["false_positive"].as<float>() << "\n"
  << "\t\tFP-sim : " << vm["FP-sim"].as<float>() << "\n"
  << "\t\tSP-error : " << vm["SP-error"].as<float>() << "\n"
  << "\t\tthreads : " << vm["threads"].as<int>() << "\n\n";
}
