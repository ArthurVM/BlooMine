/*
Main BlooMine module. Parses arguments and controls FastQ data pre-processing and thread spawning.
*/

#include "BlooMineUtils.cpp"
#include "argparse.hpp"


/****************************************************************************************************
 * Function overview:
 *  - parse arguments (vm)
 *  - initialise a FastQ instance (FQ)
 *  - call partition method to partition reads dependant on the number of threads selected
 *    (FQ.partition)
 *  - spawn threads using individual partitions generated by FastQ.partition (spawn_thread)
 *  - control output of read hits into a fastq file (hits_collection)
 ****************************************************************************************************/
int main( int argc, char** argv )
{
  // parse arguments
  po::variables_map args = parseArgs( argc, argv );

  // handle arguments
  std::string target_fasta = args["target_fasta"].as<std::string>();
  std::string fastq = args["fastq"].as<std::string>();
  int kmer = args["kmer"].as<int>();
  double first_pass_similarity = args["FP-sim"].as<double>();
  double false_positive = args["false_positive"].as<double>();
  double second_pass_error = args["SP-error"].as<double>();
  int threads = args["threads"].as<int>();
  std::string prefix = args["prefix"].as<std::string>();
  bool on_disk = args.count("on-disk") > 0; // Check if "on-disk" flag is present


  // Call the modified generateBloomFilter function
  std::pair<BloomFilter, int> BF_and_threshold = generateBloomFilter( target_fasta, 
                                                                      kmer, 
                                                                      first_pass_similarity, 
                                                                      false_positive );
  BloomFilter BF = BF_and_threshold.first;
  int fp_threshold = BF_and_threshold.second;


  // generate a kmer set from the target sequence
  std::unordered_set<std::string> target_kset = fasta2kmerset( target_fasta, 
                                                               kmer );


  // calculate the min score threshold for the target sequence for use during second-pas screening
  double spMST = calculateMinimumScoreThreshold( second_pass_error, 
                                                 kmer, 
                                                 target_kset );  

  // Check whether to run on disk or in memory
  if (on_disk) {
    // Partition the read data into individual fastqs on disk
    FastQ FQ = partitionData( fastq, 
                              threads,
                              on_disk );
    
    // Spawn threads and run the BlooMine pipeline on each fastq
    std::vector<std::future<std::vector<std::string>>> futures = spawnThreads( threads,
                                                                               kmer,
                                                                               prefix, 
                                                                               FQ, 
                                                                               BF, 
                                                                               target_kset, 
                                                                               fp_threshold, 
                                                                               spMST );
    } else {
    // Partition the read data into chunks in memory
    std::vector<std::vector<std::string>> read_data_parts = partitionData( fastq, 
                                                                           threads );

    // Spawn threads and run the BlooMine pipeline on each read partition
    std::vector<std::future<std::vector<std::string>>> futures = spawnThreads( threads,
                                                                               kmer,
                                                                               prefix, 
                                                                               read_data_parts, 
                                                                               BF, 
                                                                               target_kset, 
                                                                               fp_threshold, 
                                                                               spMST );

  }


  // Collect results from threads
  // collectResults( vm, hits_collection );


  vprint("FP-ALN", "Finished screening.", "g");

  return 0;
}